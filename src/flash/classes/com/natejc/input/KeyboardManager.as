/** * Designed to handle all things related to keyboard input with the following goals in mind: *  1) Very simple API *  2) Easy on the CPU *  3) Singleton Access * * Author: *  Nate Chatellier, e-mail: natejc@natejc.com * * Version log: *  08.26.2010		1.0		Nate Chatellier	+ First version *  11.16.2011		1.1		Nate Chatellier	+ Made key combo system more flexible *  03.06.2014		1.2		Nate Chatellier	+ Added keyPress functionality (a quick back to back keyDown and keyUp event) * * Outstanding issues: *  - KeySequence is not yet implemented (because I haven't needed this functionality yet and I'm too lazy to do it otherwise) *  * @see	http://blog.natejc.com * @see com.natejc.input.KeyCode * * Released under the MIT License: * Copyright (c) 2010 Nate Chatellier * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package com.natejc.input{	import flash.display.Stage;	import flash.events.KeyboardEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.setTimeout;	import flash.utils.clearTimeout;	/**	 * Helper functions for handling all things keyboard related.	 *	 * @author Nate Chatellier	 */	public class KeyboardManager	{		/** Stores a reference to the singleton instance. */		private static const _instance				:KeyboardManager = new KeyboardManager( SingletonLock );		/** Static class-level access to the Stage. */		public static var	stage					:Stage;		/** The amount of time (in milliseconds) that is permitted between a key down and a key up in order for a key press even to trigger. */		public static var	nPressMatchWindow		:uint = 50;		/** The amount of time (in milliseconds) that is permitted to check for a key combo before individual key down events occur instead of the combo. */		public static var	nComboMatchWindow		:uint = 55;		/** A 2d array in the form ["keyCodeString"][listenerNum] = keyDownListener. */		protected var	_aKeyDownListeners			:Array = [];		/** A 2d array in the form ["keyCodeString"][listenerNum] = keyUpListener. */		protected var	_aKeyUpListeners			:Array = [];		/** A 2d array in the form ["keyCodeString"][listenerNum] = keyPressListener. */		protected var	_aKeyPressListeners			:Array = [];		/** An array specifying whether a key is down or not. */		protected var	_aKeyDown					:Array = [];		/** An array in the form of [uint][string] = Array(uint, uint, ..., uint). The first uint represents a single keyCode that has a combo associated with it. The second string is the flattened toString() version of the array combo, and the assigned array (the part after the = sign) is an array of uints that represent each keyCode required for the combo to fire. */		protected var	_aKeyCombos					:Array = [];		/** An array in the form of [uint][string] = Array(uint, uint, ..., uint). The first uint represents a single keyCode that has a sequence associated with it. The second string is the flattened toString() version of the array sequence, and the assigned array (the part after the = sign) is an array of uints that represent each keyCode required for the sequence to fire. */		protected var	_aKeySequences				:Array = [];		/** A vector of keycodes that will be used to execute keyDownListener functions if they weren't part of a sucuessful combo. */		protected var	_vQueuedKeyDownKeyCodes		:Vector.<uint> = new Vector.<uint>();		/** An array of timer id's used to validate a key press vs just a key down and up. Stored in the form _aKeyPressValidationTimers[keyCodeString] = nTimerID. */		protected var	_aKeyPressValidationTimers	:Array = [];		/** Keep track of the id used for the combo match window timer. */		protected var	_tComboMatchWindowTimer		:Timer;		/* ---------------------------------------------------------------------------------------- */		/**		 * Constructs the KeyboardManager object.		 *		 * @param	lock	This class is a singleton and should not be externally instantiated.		 */		public function KeyboardManager($lock:Class)		{			if ($lock != SingletonLock)				throw new Error("KeyboardManager is a singleton and should not be instantiated. Use KeyboardManager.instance instead.");						_tComboMatchWindowTimer = new Timer(nComboMatchWindow, 1);			_tComboMatchWindowTimer.addEventListener(TimerEvent.TIMER, this.comboWindowPassed, false, 0, true);		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Returns an instance to this class.		 *		 * @return		An instance to this class.		 */		public static function get instance():KeyboardManager		{			return _instance;		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Initializes this class. This must be called before any other operations can be done.		 *		 * @param	$stage	A reference to the Stage.		 */		public static function init($stage:Stage):void		{			if (!$stage)				throw new Error("*** ERROR in KeyboardManager::init() --> $stage must be a valid reference to the Stage.");			KeyboardManager.stage = $stage;			KeyboardManager.stage.addEventListener(KeyboardEvent.KEY_DOWN, KeyboardManager.instance.keyDownHandler, false, 0, true);			KeyboardManager.stage.addEventListener(KeyboardEvent.KEY_UP, KeyboardManager.instance.keyUpHandler, false, 0, true);		}		/* ---------------------------------------------------------------------------------------- */		/**		 * @private		 * Handles key down events.		 *		 * @param	$e	The dispatched KeyboardEvent.KEY_DOWN event.		 */		protected function keyDownHandler($e:KeyboardEvent):void		{			// if the key is already recorded as being down, then just return			if (_aKeyDown[$e.keyCode] == true)				return;						// note that the key is pressed down			_aKeyDown[$e.keyCode] = true;						var aListenerList:Array						// first check to see if this key is part of a combo			if (this.checkForKeyCombos($e.keyCode, false))			{				if (!_tComboMatchWindowTimer.running)					_tComboMatchWindowTimer.start();				if (_vQueuedKeyDownKeyCodes.indexOf($e.keyCode) < 0)					_vQueuedKeyDownKeyCodes.push($e.keyCode);			}			else // if it's not part of a combo then go ahead and execute the key down listeners (if they exist)			{				// kill the combo timer if it was running since the current key being pressed down is not part of a combo				if (_tComboMatchWindowTimer.running)					_tComboMatchWindowTimer.reset();								// call all the functions that we are listening for only if this key is not part of a combo (otherwise they will still get called if the combo is not completed after a small period of time)				aListenerList = _aKeyDownListeners[String($e.keyCode)];				if (aListenerList)				{					for (var i:uint = 0; i < aListenerList.length; i++)						aListenerList[i].apply();				}			}						// start the key press validation timer (if it's being listened for)			aListenerList = _aKeyPressListeners[String($e.keyCode)];			if (aListenerList)				_aKeyPressValidationTimers[$e.keyCode] = setTimeout(keyPressWindowPassed, nPressMatchWindow, $e.keyCode);		}				/* ---------------------------------------------------------------------------------------- */				/**		 * @private		 * Clears the timer index and possibility of the specified keyCode triggering a keyPress event.		 *		 * @param	$nKeyCode		The KeyCode of the key that no longer qualifies for a key press event.		 */		protected function keyPressWindowPassed($nKeyCode:uint):void		{			_aKeyPressValidationTimers[$nKeyCode] = 0;		}				/* ---------------------------------------------------------------------------------------- */				/**		 * @private		 * If this function is called, then it means that the user didn't complete the key combo quick enough so they must be normal keyDown events instead of a single key combo event.		 * 		 * @param	$e	The dispatched TimerEvent.		 */		protected function comboWindowPassed($e:TimerEvent = null):void		{			_tComboMatchWindowTimer.reset();						// check for combos and execute the listeners for any combos that were matched			if (!this.checkForKeyCombos(_vQueuedKeyDownKeyCodes[_vQueuedKeyDownKeyCodes.length-1], true))			{				// if none were matched, then execute all keyDown listeners that exist for the keys that were pressed down instead				var aListenerList:Array;				for (var i:uint = 0; i < _vQueuedKeyDownKeyCodes.length; i++)				{					aListenerList = _aKeyDownListeners[String(_vQueuedKeyDownKeyCodes[i])];					if (aListenerList)					{						for (var j:uint = 0; j < aListenerList.length; j++)							aListenerList[j].apply();					}				}			}						_vQueuedKeyDownKeyCodes = new Vector.<uint>();		}		/* ---------------------------------------------------------------------------------------- */		/**		 * @private		 * Handles key up events.		 *		 * @param	$e	The dispatched KeyboardEvent.KEY_UP event.		 */		protected function keyUpHandler($e:KeyboardEvent):void		{			if ($e.keyCode == 144) $e.keyCode = 71; // fix for Adobe bug. See: http://natejc.com/blog/2010/11/flash-bug-g-keycode-mysteriously-different-on-key-down-vs-key-up/						// note that the key is now up.			_aKeyDown[$e.keyCode] = false;			var aListenerList:Array = _aKeyUpListeners[String($e.keyCode)];			if (aListenerList)			{				for (var i:uint = 0; i < aListenerList.length; i++)					aListenerList[i].apply();			}						// check for a valid key press event			if (_aKeyPressValidationTimers[$e.keyCode] != 0)			{				keyPressHandler($e)				clearTimeout(_aKeyPressValidationTimers[$e.keyCode]);				_aKeyPressValidationTimers[$e.keyCode] = 0;			}		}		/* ---------------------------------------------------------------------------------------- */		/**		 * @private		 * Handles key up events.		 *		 * @param	$e	The dispatched KeyboardEvent.KEY_UP event.		 */		protected function keyPressHandler($e:KeyboardEvent):void		{			var aListenerList:Array = _aKeyPressListeners[String($e.keyCode)];			if (aListenerList)			{				for (var i:uint = 0; i < aListenerList.length; i++)					aListenerList[i].apply();			}		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Connects a specific keyboard key down event to a function.		 *		 * @param	$nKeyCode			The key code of the key that was pressed down.		 * @param	$listener			The function that should be called when this key is pressed down.		 * @param	$bRemoveOthers		True if all other listeners for this event should be removed (if they exist).		 */		public function addKeyDownListener($nKeyCode:uint, $listener:Function, $bRemoveOthers:Boolean = false):void		{			var aListeners:Array = this.addListener(_aKeyDownListeners[String($nKeyCode)], $listener, $bRemoveOthers);			_aKeyDownListeners[String($nKeyCode)] = aListeners;		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Connects a specific keyboard key up event to a function.		 *		 * @param	$nKeyCode			The key code of the key that was released.		 * @param	$listener			The function that should be called when this key is released.		 * @param	$bRemoveOthers		True if all other listeners for this event should be removed (if they exist).		 */		public function addKeyUpListener($nKeyCode:uint, $listener:Function, $bRemoveOthers:Boolean = false):void		{			_aKeyUpListeners[String($nKeyCode)] = this.addListener(_aKeyUpListeners[String($nKeyCode)], $listener, $bRemoveOthers);		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Connects a specific keyboard key press event (i.e. a down and an up event wihin a small perioud of time) to a function.		 * Note: the performance implications of a keyPress event are slightly worse then a simple keyDown event. Use keyPress only if truly needed.		 *		 * @param	$nKeyCode			The key code of the key that was pressed.		 * @param	$listener			The function that should be called when this key is pressed.		 * @param	$bRemoveOthers		True if all other listeners for this event should be removed (if they exist).		 */		public function addKeyPressListener($nKeyCode:uint, $listener:Function, $bRemoveOthers:Boolean = false):void		{			_aKeyPressListeners[String($nKeyCode)] = this.addListener(_aKeyPressListeners[String($nKeyCode)], $listener, $bRemoveOthers);		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Connects a specific combination of keys pressed simultaneously to a function.		 *		 * @param	$aKeyCodes			An array of key codes that should be pressed simultaneously.		 * @param	$listener			The function that should be called when this key combo occurs.		 * @param	$bRemoveOthers		True if all other listeners for this event should be removed (if they exist).		 */		public function addKeyComboListener($aKeyCodes:Array, $listener:Function, $bRemoveOthers:Boolean = false):void		{			var sKeyIndex:String = String($aKeyCodes);			var keyComboType:KeyComboType;			for (var i:int = 0; i < $aKeyCodes.length; i++)			{				_aKeyCombos[$aKeyCodes[i]] ||= new Array();				if (_aKeyCombos[$aKeyCodes[i]][sKeyIndex])				{					keyComboType = _aKeyCombos[$aKeyCodes[i]][sKeyIndex];				}				else				{					keyComboType = new KeyComboType();					_aKeyCombos[$aKeyCodes[i]][sKeyIndex] = keyComboType;				}				keyComboType.aKeyCombination = $aKeyCodes;				this.addListener(keyComboType.aListeners, $listener, $bRemoveOthers);			}		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Connects a specific sequence of keys pressed within a short time frame to a function.		 *		 * @param	$aKeyCodes			An array of key codes that should be pressed in sequence.		 * @param	$listener			The function that should be called when this key sequence occurs.		 * @param	$bRemoveOthers		True if all other listeners for this event should be removed (if they exist).		 */		public function addKeySequenceListener($aKeyCodes:Array, $listener:Function, $bRemoveOthers:Boolean = false):void		{// TODO: zz ~NJC			var sKeyIndex:String = String($aKeyCodes);			var keySequenceType:KeyComboType;			for (var i:int = 0; i < $aKeyCodes.length; i++)			{								_aKeySequences[$aKeyCodes[i]] ||= new Array();				if (_aKeySequences[$aKeyCodes[i]][sKeyIndex])				{					keySequenceType = _aKeySequences[$aKeyCodes[i]][sKeyIndex];				}				else				{					keySequenceType = new KeyComboType();					_aKeySequences[$aKeyCodes[i]][sKeyIndex] = keySequenceType;				}				keySequenceType.aKeyCombination = $aKeyCodes;				this.addListener(keySequenceType.aListeners, $listener, $bRemoveOthers);			}		}		/* ---------------------------------------------------------------------------------------- */		/**		 * @private		 * Adds a listener to the specified array if it doesn't already exist.		 *		 * @param	$aListenerList		The array of listeners that should be added to.		 * @param	$listener			The function that should be added to the array.		 * @param	$bRemoveOthers		True if all other listeners in this array should be removed first.		 */		protected function addListener($aListenerList:Array, $listener:Function, $bRemoveOthers:Boolean = false):Array		{			if (!KeyboardManager.stage)				throw new Error("*** ERROR in KeyboardManager::addListener() --> KeyboardManager.init(stageRef) must be called before listeners can be accessed.");			if (!$aListenerList || $bRemoveOthers)				$aListenerList = [];			if ($aListenerList.indexOf($listener) >= 0)				return $aListenerList; // don't add the same listener twice			$aListenerList.push($listener);			return $aListenerList;		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Removes a previously added key down event listening function.		 *		 * @param	$nKeyCode			The key code of the key that was pressed down.		 * @param	$listener			The function that was being called when this key was pressed down or null to remove all listeners..		 */		public function removeKeyDownListener($nKeyCode:uint, $listener:Function = null):void		{			var aListenerList:Array = _aKeyDownListeners[String($nKeyCode)];			if (!aListenerList)				return;						var nListenerIndex:int = aListenerList.indexOf($listener);			if (nListenerIndex >= 0)			{				if (aListenerList.length > 1)					_aKeyDownListeners[String($nKeyCode)] = aListenerList.splice(nListenerIndex, 1);				else					_aKeyDownListeners[String($nKeyCode)] = [];			}		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Removes a previously added key up event listening function.		 *		 * @param	$nKeyCode			The key code of the key that was released.		 * @param	$listener			The function that was being called when this key was pressed down or null to remove all listeners..		 */		public function removeKeyUpListener($nKeyCode:uint, $listener:Function = null):void		{			var aListenerList:Array = _aKeyUpListeners[String($nKeyCode)];			if (!aListenerList)				return;						var nListenerIndex:int = aListenerList.indexOf($listener);			if (nListenerIndex >= 0)			{				if (aListenerList.length > 1)					_aKeyUpListeners[String($nKeyCode)] = aListenerList.splice(nListenerIndex, 1);				else					_aKeyUpListeners[String($nKeyCode)] = [];			}		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Removes a previously added key press event listening function.		 *		 * @param	$nKeyCode			The key code of the key that was pressed.		 * @param	$listener			The function that was being called when this key was pressed down or null to remove all listeners..		 */		public function removeKeyPressListener($nKeyCode:uint, $listener:Function = null):void		{			var aListenerList:Array = _aKeyPressListeners[String($nKeyCode)];			if (!aListenerList)				return;						var nListenerIndex:int = aListenerList.indexOf($listener);			if (nListenerIndex >= 0)			{				if (aListenerList.length > 1)					_aKeyPressListeners[String($nKeyCode)] = aListenerList.splice(nListenerIndex, 1);				else					_aKeyPressListeners[String($nKeyCode)] = [];			}		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Removes all previously added listening functions from single key events (up, down, press).		 *		 * @param	$nKeyCode			The key code of the key that should have all of its listeners cleared.		 */		public function removeAllKeyListeners($nKeyCode:uint):void		{			this.removeKeyDownListener($nKeyCode);			this.removeKeyUpListener($nKeyCode);			this.removeKeyPressListener($nKeyCode);		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Removes a previously added key combo event listening function.		 *		 * @param	$aKeyCodes			An array of key codes that composed the combo.		 * @param	$listener			The function that was being called when this key combo was pressed or null to remove all listeners for this combo.		 */		public function removeKeyComboListener($aKeyCodes:Array, $listener:Function = null):void		{			var sKeyIndex:String = String($aKeyCodes);						for (var i:int = 0; i < $aKeyCodes.length; i++)			{				if (_aKeyCombos[$aKeyCodes[i]] && _aKeyCombos[$aKeyCodes[i]][sKeyIndex])				{					_aKeyCombos[$aKeyCodes[i]][sKeyIndex] = null;				}			}		}				/* ---------------------------------------------------------------------------------------- */				/**		 * Removes a previously added key sequence event listening function.		 *		 * @param	$aKeyCodes			An array of key codes that composed the sequence.		 * @param	$listener			The function that was being called when this key sequence was pressed or null to remove all listeners for this sequence.		 */		public function removeKeySequenceListener($aKeyCodes:Array, $listener:Function = null):void		{			var sKeyIndex:String = String($aKeyCodes);						for (var i:int = 0; i < $aKeyCodes.length; i++)			{				if (_aKeySequences[$aKeyCodes[i]] && _aKeySequences[$aKeyCodes[i]][sKeyIndex])				{					_aKeySequences[$aKeyCodes[i]][sKeyIndex] = null;				}			}		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Given a single key pressed keyCode, this function will check to see if this key completes any key combinations.		 *		 * @param	$nKeyCode			The keyCode that was pressed.		 * @param	$bExecuteListeners	True if the listener functions that were matched should be executed.		 * @return						True if this key is part of a combo (note that this doesn't imply that the combo was completed yet).		 */		protected function checkForKeyCombos($nKeyCode:uint, $bExecuteListeners:Boolean = true):Boolean		{			if (!_aKeyCombos[$nKeyCode])				return false;						var bIsPartOfKeyCombo:Boolean = false;			for each (var keyComboType:KeyComboType in _aKeyCombos[$nKeyCode])			{				// $nKeyCode is not part of a combo				if (!keyComboType)					continue;								// a match was found, so check the rest of the keys of the combo				if (!$bExecuteListeners)					bIsPartOfKeyCombo = true;								for (var i:int = 0; i < keyComboType.aKeyCombination.length; i++)				{					//if (!this.isKeyDown(keyComboType.aKeyCombination[i]))					if (_vQueuedKeyDownKeyCodes.indexOf(keyComboType.aKeyCombination[i]) < 0)					{						break;					}					else if (i == keyComboType.aKeyCombination.length-1)					{						if ($bExecuteListeners)						{							bIsPartOfKeyCombo = true;							for (var j:uint = 0; j < keyComboType.aListeners.length; j++)								keyComboType.aListeners[j].apply();						}					}				}			}						return bIsPartOfKeyCombo;		}		/* ---------------------------------------------------------------------------------------- */		/**		 * Returns true if the specified key is currently depressed; false otherwise.		 *		 * @param	$nKeyCode		The key code of the key that should be tested.		 * @return					True if the specified key is currently depressed; false otherwise.		 */		public function isKeyDown($nKeyCode:uint):Boolean		{			return (_aKeyDown[$nKeyCode] && String(_aKeyDown[$nKeyCode]) == "true");		}		/* ---------------------------------------------------------------------------------------- */	}}class KeyComboType{	public var aKeyCombination:Array;	public var aListeners:Array = [];}class SingletonLock {} // Do nothing, this is just to prevent external instantiation.